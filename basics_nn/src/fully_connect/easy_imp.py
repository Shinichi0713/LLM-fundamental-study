import numpy as np

# --- 1. 定義（学習されたパラメータ） ---

# 重み行列 W: 形状 (出力の次元数, 入力の次元数)
# 今回は出力が「満足度」の1次元なので、(1, 3)の行列として定義します。
W = np.array([[10.0, -5.0, -10.0]])

# バイアスベクトル b: 形状 (出力の次元数)
# 出力が1次元なので、要素が1つのベクトルです。
b = np.array([50.0])

print(f"重み W の形状: {W.shape}")
print(f"バイアス b の形状: {b.shape}")
print("-" * 30)


# --- 2. 入力データの準備 (複数バッチ) ---

# 入力行列 X: 形状 (バッチサイズ, 入力の次元数)
# A店とB店の2つのデータ（バッチサイズ=2）を一度に入力します。
X = np.array([
    [10.0, 1.0, 1.0],  # A店: (味, 価格, 行列)
    [3.0, 0.5, 0.0]    # B店: (味, 価格, 行列)
])

print(f"入力 X の形状: {X.shape} (2バッチ, 3特徴量)")
print("-" * 30)


# --- 3. 全結合層の計算 (線形変換) ---

# 処理 1: 行列の積 (X と W の転置 W.T)
# X (2, 3) と W.T (3, 1) のドット積の結果は (2, 1) になります。
# 転置 (W.T) を使うことで、Torchの nn.Linear と同じ計算順序になります。
Z = np.dot(X, W.T) 

# 処理 2: バイアス b の加算
# Z (2, 1) と b (1,) の間でブロードキャストが行われ、各行にバイアスが加算されます。
Y = Z + b

# --- 4. 結果の表示 ---

print("計算結果 Z (Wx):")
print(Z)
print("\n最終出力 Y (Wx + b):")
print(Y)

print("\n--- 結論 ---")
print(f"A店の満足度: {Y[0, 0]:.1f}")
print(f"B店の満足度: {Y[1, 0]:.1f}")